#ndebug

ruby用デバッグプログラムです。
rubyの実行ファイルを内包し、標準で提供されるデバッグプログラムが使えない場合に、デバッグ機能を提供します。

##使い方

デバッグ対象のソースコードにrequireで"ndebug"を追加してください。  
```
require "ndebug"
```

##デバッグのやり方

実行後すぐにndebugのコンソールでコマンド入力できるようになります。  
ブレイクポイントを貼りたい箇所で `>ba ソースファイル 行数` とすればブレイクポイントが貼れます。  
ブレイクポイントを貼ったら `>-` を入力してプログラムを実行してください。  

ウォッチ式でブレイクポイントの変数を参照したい場合は `> wa ウォッチ式` とします。  
追加したウォッチ式は `>w` で確認できます。詳細はコマンドの一覧を確認ください。  


##コマンドについて
* [ブレイクポイントの追加(ba)](#ブレイクポイントの追加)
* [ブレイクポイントの削除(bd)](#ブレイクポイントの削除)
* [ブレイクポイントの一覧表示(b)](#ブレイクポイントの一覧表示)
* [ブレイクポイントのファイル保存(bo)](#ブレイクポイントのファイル保存)
* [ブレイクポイントのファイル読み込み(bi)](#ブレイクポイントのファイル読み込み)
* [ウォッチ式の追加(wa)](#ウォッチ式の追加)
* [ウォッチ式の削除(wd)](#ウォッチ式の削除)
* [ウォッチ式の一覧表示(w)](#ウォッチ式の一覧表示)
* [ウォッチ式のファイル保存(wo)](#ウォッチ式のファイル保存)
* [ウォッチ式のファイル読み込み(wi)](#ウォッチ式のファイル読み込み)
* [ステップイン(+)](#ステップイン)
* [ブレイク解除(-)](#ブレイク解除)
* [evalコマンドの実行(e)](#evalコマンドの実行)

---
### ブレイクポイントの追加
  ブレイクポイントの追加を行います。追加したブレイクポイントは[ブレイクポイントの一覧表示(b)](#ブレイクポイントの一覧表示)で確認できます。  
  `file`は"*"で全ファイル、部分一致でもブレイクします。

#### コマンド
  ```
  >ba file line
  ```
  **file :** ファイル名
  **line :** 行数

#### サンプル
  ```
  >ba sample.rb 10`
  [add break point] sample.rb(10)
  ```

---
### ブレイクポイントの削除
  ブレイクポイントの削除を行います。削除に必要となるインデックス番号は[ブレイクポイントの一覧表示(b)](#ブレイクポイントの一覧表示)で確認できます。  
  `bd -a`とすることで全てのブレイクポイントの削除が行えます。

#### コマンド
  ```
  >bd index
  ```
  **index :** ブレイクポイントのインデックス番号
  
#### サンプル
  ```
  >ba sample.rb 10
  [add break point] sample.rb(10)
  >b
  ----------break list----------
   0: sample.rb(10)
  ------------------------------
  >bd 0
  [delete break point]
  >b
  ----------break list----------
  ------------------------------
  ```

---
### ブレイクポイントの一覧表示
  ブレイクポイントの一覧表示を行います。一覧は_**インデックス番号**: **対象ソース**(**行数**)_で表示されます。

#### コマンド
  ```
  >b
  ```

#### サンプル
  ```
  >b
  ----------break list----------
   0: test.rb(55)
   1: model/hoge(66)
   2: *(77)
  ------------------------------
  ```

---
### ブレイクポイントのファイル保存
  ブレイクポイントの情報をファイルに保存します。
  保存される内容はプレーンテキストです。

#### コマンド
  ```
  >bo outputfile
  ```
  **outputfile :** 出力ファイル

#### サンプル
  ```
  >bo breakfile
  [written break point file] "breakfile"
  ```

#### 出力ファイル内容
  ```
  test.rb:55
  model/hoge:66
  *:77
  ```

---
### ブレイクポイントのファイル読み込み
  `bo`コマンドで出力したファイルを読み込みます。  
  デバッグする度にブレイクポイントの設定を行うと大変なので、テキストで編集したファイルを最初に読み込むと便利です。  
  また、デバッグ中も`bd -a`と`bi`コマンドを組み合わせることで`ba`コマンドで一つ一つ登録しなくても良くて便利です。

#### コマンド
  ```
  >bi inputfile
  ```
  **inputfile :** 入力ファイル

#### サンプル
  ```
  >bi breakfile
  [loaded break point file] "breakfile"
  >b
  ----------break list----------
   0: test.rb(55)
   1: model/hoge(66)
   2: *(77)
   3: hoo(1)
  ------------------------------
  ```

#### 入力ファイル内容
  ```
  test.rb:55
  model/hoge:66
  *:77
  hoo:1
  ```

---

### ウォッチ式の追加
  ウォッチ式の追加を行います。追加したウォッチ式は[ウォッチ式の一覧表示(w)](#ウォッチ式の一覧表示)で確認できます。
  ウォッチ式はブレイクポイントから見た変数、クラス変数、インスタンス変数を確認できます。

#### コマンド
  ```
  >wa exp
  ```
  **exp :** ウォッチ式

##### ウォッチ式の書き方
  * ローカル変数の参照  
    ローカル変数名を`exp`に入力することで参照できます。

  * インスタンスとインスタンス変数の参照  
    インスタンスはローカル変数と同様に`exp`にインスタンスが格納されている変数名を入力します。  
    インスタンス内のメンバ変数を参照するには、`.`で連結してその後ろに`@`から始まるメンバ変数を入力します。  
    例、`obj.@member`  
    メンバ変数がさらにクラスインスタンスを内包している場合は、`.`で連結していくことができます。  
    クラスメソッド内で対象のインスタンスのメンバ変数を参照する場合は`@メンバ変数`で参照が可能です。
    
  * クラスとクラス変数の参照  
    クラス変数を参照するには、`exp`に`クラス名.@@クラス変数`を入力します。  
    なお、インスタンスからクラス変数の参照はできません。

  * グローバル変数の参照  
    グローバル変数を参照するには、`exp`に`$グローバル変数`を入力します。
  
  * 配列内の参照  
    配列の内部を参照する際は配列を指す変数名の後ろに`[]`を入力します。  
    例、`obj.@member.@array[0].@member`  
    配列が長くなる場合に特定の場所だけを見る、配列にさらにインスタンスが格納されている場合に参照できます。

  * メソッドの参照  
    `exp`にメソッドを書いてもそのメソッド呼び出しは行われません。
    しかし、対象のメソッドがインスタンスに宣言されているかを確認できます。

#### サンプル
  ```
  >wa obj1
  [add watch exp] obj1
  >wa obj1.@a.@b
  [add watch exp] obj1.@a.@b
  ```

---

### ウォッチ式の削除
  ウォッチ式の削除を行います。削除に必要となるインデックス番号は[ウォッチ式の一覧表示(b)](#ウォッチ式の一覧表示)で確認できます。  
  `wd -a`とすることで全てのウォッチ式の削除が行えます。

#### コマンド
  ```
  >wd index
  ```
  **index :** ウォッチ式のインデックス番号

#### サンプル
  ```
  >w
  ----------watch list----------
   0: [obj1] : #<A:0x007fb629037c80>
   1: [obj1.@a] : [@b:[1, 2, 3] @bb:]
   2: [obj1.@a.@b] : [1, 2, 3]
   3: [obj1.@a.@b[0]] : 1
   4: [obj1.@a.print] : #<Method: B(Kernel)#print>
   5: [A.@@aa] : 0
   6: [B.@@bb] : 1
   7: [obj2] : NON!
  ------------------------------
  >wd 7
  [delete watch exp]
  >w
  ----------watch list----------
   0: [obj1] : #<A:0x007fb629037c80>
   1: [obj1.@a] : [@b:[1, 2, 3] @bb:]
   2: [obj1.@a.@b] : [1, 2, 3]
   3: [obj1.@a.@b[0]] : 1
   4: [obj1.@a.print] : #<Method: B(Kernel)#print>
   5: [A.@@aa] : 0
   6: [B.@@bb] : 1
  ------------------------------
  ```

---

### ウォッチ式の一覧表示
  ウォッチ式の一覧表示を行います。`wa`コマンドで追加したウォッチ式の内容の確認が行えます。
  ブレイクポイントの位置から参照できないウォッチ式は`NON!`が表示されます。

#### コマンド
  ```
  >w
  ```

#### サンプル
  ソースコード(sample.rb)
  ```
  require "./ndebug"
  
  class A
  	@a
  	@@aa = 0
  
  	def initialize(val)
  		@a = B.new(val)
  	end
  
  	def print
  		@@aa += 1
  		printf("[@a:%s @aa:%s]\n", @a, @@aa)
  	end
  end
  
  class B
  	@b
  	@@bb = 0
  
  	def initialize(val)
  		@b = [val, val + 1, val + 2]
  		@@bb += 1
  	end
  
  	def to_s
  		sprintf("[@b:%s @bb:%s]", @b, @bb)
  	end
  end
  
  def test
  	obj1 = A.new(1)
  	obj1.print
  	obj1.print
  end
  
  test
  obj2 = A.new(2)
  obj2.print
  obj2.print
  ```
  コマンド
  ```
  sample.rb:34  Object::test(line) bind:main
  >w
  ----------watch list----------
   0: [obj1] : #<A:0x007fb629037c80>
   1: [obj1.@a] : [@b:[1, 2, 3] @bb:]
   2: [obj1.@a.@b] : [1, 2, 3]
   3: [obj1.@a.@b[0]] : 1
   4: [obj1.@a.print] : #<Method: B(Kernel)#print>
   5: [A.@@aa] : 0
   6: [B.@@bb] : 1
   7: [obj2] : NON!
  ------------------------------
  ```

---

### ウォッチ式のファイル保存
  ウォッチ式の情報をファイルに保存します。
  保存される内容はプレーンテキストです。

#### コマンド
  ```
  >wo outputfile
  ```
  **outputfile :** 出力ファイル

#### サンプル
  ```
  >wo watchfile
  [written watch point file] "watchfile"
  ```

#### 出力ファイル内容
  ```
  obj1
  obj1.@a
  obj1.@a.@b
  obj1.@a.@b[0]
  obj1.@a.print
  A.@@aa
  B.@@bb
  ```

---
### ウォッチ式のファイル読み込み
  `wo`コマンドで出力したファイルを読み込みます。  
  ブレイクポイント毎に一つ一つウォッチ式の設定を行うと大変なので、テキストで編集したファイルをブレイクポイントの都度読み込むと便利です。  
  `wd -a`コマンドと組み合わせることでウォッチしたい内容をテキストエディタなどで編集しながら、又は事前に用意した内容ですぐに確認できます。

#### コマンド
  ```
  >wi inputfile
  ```
  **inputfile :** 入力ファイル

#### サンプル
  ```
  >wi watchfile
  [loaded watch point file] "watchfile"
  >w
  ----------watch list----------
   0: [obj1] : NON!
   1: [obj1.@a] : NON!
   2: [obj1.@a.@b] : NON!
   3: [obj1.@a.@b[0]] : NON!
   4: [obj1.@a.print] : NON!
   5: [A.@@aa] : 0
   6: [B.@@bb] : 1
  ------------------------------
  ```

#### 入力ファイル内容
  ```
  obj1
  obj1.@a
  obj1.@a.@b
  obj1.@a.@b[0]
  obj1.@a.print
  A.@@aa
  B.@@bb
  ```

---

### ステップイン
  対象ステップから次のステップに移ります。

#### コマンド
  ```
  >+
  ```

#### サンプル
  ```
  >+
  sample.rb:13  A::print(line) bind:#<A:0x007fb629037c80>
  >+
  sample.rb:14  A::print(line) bind:#<A:0x007fb629037c80>
  ```

---

### ブレイク解除
  ブレイクポイントやステップ実行していた状況を解除します。  
  解除したら途中でブレイクが貼れないので注意が必要です。

#### コマンド
  ```
  >-
  ```

---

### evalコマンドの実行
  ブレイクポイントの箇所で**eval命令**を実行します。  
  コマンドの内容によっては変な動きをしたり、エラーでプログラムが停止します。  
  変数の変更を行う場合に使います。（純粋なevalなのでメソッド呼び出し等も可能です。）

#### コマンド
  ```
  >e command
  ```
  **command :** eval命令の内容

#### サンプル
  ```
  >w
  ----------watch list----------
   0: [obj1] : #<A:0x007fb629037c80>
   1: [obj1.@a] : [@b:[1, 2, 3] @bb:]
   2: [obj1.@a.@b] : [1, 2, 3]
   3: [obj1.@a.@b[0]] : 1
   4: [obj1.@a.print] : #<Method: B(Kernel)#print>
   5: [A.@@aa] : 2
   6: [B.@@bb] : 1
  ------------------------------
  >e obj1 = "aaa"
  [do eval] obj1 = "aaa"
  >w
  ----------watch list----------
   0: [obj1] : aaa
   1: [obj1.@a] : NON!
   2: [obj1.@a.@b] : NON!
   3: [obj1.@a.@b[0]] : NON!
   4: [obj1.@a.print] : NON!
   5: [A.@@aa] : 2
   6: [B.@@bb] : 1
  ------------------------------
  ```

---

## Notes
  気にしている事（バグもある？）
  * evalで不正コマンドな場合にブレイク解除される。
  * 全ての処理でブレイクするが、ruby側のC言語コールは無視していいのでは？
  * そもそも、ちゃんとしたプログラムでndebugを活用してないからソースコードの位置等で使いづらいとかあるかも。あえて一本のソースにまとめた方がいい？
